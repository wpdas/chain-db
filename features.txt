[P] = Recurso do produto
    = Recurso técnico

1 - [P] Criar Modelo de Tabelas como Contrato Inteligente;
2 - [P] A porta principal do ChainDB é o 2818;
2 - Cada bloco é salvo no disco;
3 - Quando é requisitado leitura de blocos, eles são lidos do disco e postos na memoria
enquanto o processo durar.
4 - Uma referencia do último bloco é guardado no arquivo "data/cur-block.inf". Isso é feito
para que seja possível saber a partir de qual bloco os dados devem ser lidos ou novos blocos
criados.
5 - Usando Borsh para serializar o bloco (produz arquivo menor que json e suporta mais tipos
de dados)
6 - Cada bloco é salvo num arquivo .blk;
7 - A referencia do ultimo bloco fica salvo no arquivo cur-block.inf;
8 - O sistema (core) sempre tentará usar o db_access_key para
encriptografar / decriptografar os blocos
8.1 - Caso um dado nao seja corretamente decompilado (por erro de chave), é retornado
um aviso de "Banco de Dados não existe na rede"
9 - Transferencia de unidades:
// Dados de transferencia - ser executado
// 1 - TransferUnitsData: from, to, units
// 1.1 - FROM: Salva sob o contrato hash(db_access_key + user_from_id + "core-transfer-table");
// 1.2 - TO: Salva sob o contrato hash(db_access_key + user_to_id + "core-transfer-table");
// [desta forma, é possivel buscar transacoes do usuario passando
// o db_access_key + user_from_id.]
// 2 - Cria transação para atualizacao de units para FROM;
// 3 - Cria transaçao para atualizacao de units para para TO;
10 - Dados criptografados, somente quem gera o dado, tem controle sobre ele;


--- pendente

1 - Criar recurso para transferencia de units (entre contas);
2 - CLI deve usar o recurso de Result, Error para chamadas;
3 - Gerar os .blk usando algum tipo de assinatura, assim nao fica facil
decompilar o arquivo. (pub / priv key).
4 - Remover o uso do Lazy (náo é necessario)
5 - get_chain() -> deve ter um filtro para buscar os blocos até achar o valor,
e não buscar todos os blocos, alocar em memoria e depois fazer a busca. Isso vai 
prejudicar a memória se continuar no jeito atual. - DONE

6 - Criar os core contracts dentro da pasta/mod "core_tables" - DONE
6.1 - Criar metodo para criar DB [salvar num core table] - IGNORADO
6.2 - Criar método para checar se um DB existe
6.3 - Create Account: Usar email para evitar a colisao de mesma conta
Salva o user_name em um contrato/tabela (core-table) diferente para que seja possível
fazer uma comparacao rapida e ver se o user_name já está sendo utilizado. - DONE
7 - Usar o db_access_key para encriptografar e decriptografar blocos - DONE
8 - Criar testes
9 - Tratar o que puder de unwrap()
9 - Usar compressao de arquivo? (zip?) - EM PROGRESSO
10 - Mudar os Types de Requisicoes HTTP para o final Payload ao invés de Data
11 - Implantar sistema de query?
12 - IMPORTANTE: porque estou serializando o data de transacoes com json?
Eu sei que preciso passar o "data" como string, mas... talvez eu possa simplesmente
mudar o tipo para ser um Vec<u8>, e decompilar ele quando for requisitado
13 - Implementar feature para buscar transacoes by user_id - DONE


// O Bloco continua legível, apenas suas transacoes sao encriptografadas
// O Bloco é salvo em Base64 contendo dentro de si as transactions (encriptografas usando AesEcb)
// Borsh é usado para gerar string de bytes, gera final menor que json
// Processo baseado no que gerou menos dados no final do arquivo

[IMPORTANTE] Nao é possivel user Borsh por causa da estruta de dados. As vezes o dado da transacao é desconhecido
pelo sistema, ja que ele vem do client.


---- APP DE EXEMPLO PARA DEMO ----
1 - Tracking - Aplicativo para guardar posição de usuário/carro
1.1 - Depois, poder ver o trajeto percorrido no maps

2 - Delivery Tracking - Registra o lugar que um produto emprestado (de uma empresa) está.
2.1 - É possivel ver todo o historico do produto, usuários que o alugaram, lugares onde
pararam...

3 - Traquear temperatura do dia para levantamento de relatorio semanal, mensal, anual...



IMPORTANTE: Corrigir o problema de converter Vec<u8> em string literalmente números.
Usar o Base64VecU8 pra isso. Vai diminuir o tamanho do dado encriptografado.