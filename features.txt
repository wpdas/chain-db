[P] = Recurso do produto
    = Recurso técnico

1 - [P] Criar Modelo de Tabelas como Contrato Inteligente;
2 - [P] A porta principal do ChainDB é o 2818;
3 - Cada bloco é salvo no disco;
4 - Quando é requisitado leitura de blocos, eles são lidos do disco e postos na memoria
enquanto o processo durar.
5 - Uma referencia do último bloco é guardado no arquivo "data/cur-block.inf". Isso é feito
para que seja possível saber a partir de qual bloco os dados devem ser lidos ou novos blocos
criados.
6 - Usando JSON para serializar o bloco;
7 - Cada bloco é salvo num arquivo .blk;
9.1 - Caso um dado nao seja corretamente decompilado (por erro de chave), é retornado
um aviso de "Banco de Dados não existe na rede"
10 - Transferencia de unidades:
// Dados de transferencia - ser executado
// 1 - TransferUnitsData: from, to, units
// 1.1 - FROM: Salva sob o contrato hash(db_access_key + user_from_id + "core-transfer-table");
// 1.2 - TO: Salva sob o contrato hash(db_access_key + user_to_id + "core-transfer-table");
// [desta forma, é possivel buscar transacoes do usuario passando
// o db_access_key + user_from_id.]
// 2 - Cria transação para atualizacao de units para FROM;
// 3 - Cria transaçao para atualizacao de units para para TO;
11 - Dados criptografados, somente quem gera o dado, tem controle sobre ele;
11.1 - Criptografia é opcional. Deafult de ativação = false;
11.2 - Quando ativado, o dado gerado é quase 50% maior que o dado sem criptografia adicional;
11.3 - var no sistema para ativação ou não: USE_AESECB_ENCRYPTION;
11.4 - O sistema (core) usará o db_access_key para encriptografar / decriptografar os blocos;
12 - Ações default do sistema: criar conta de usuário, fazer transferencia de unidades
entre dois usuarios e buscar dados do usuário.
13 - Cada tabela é gerada usando um struct que quando persistido, gera uma transação dentro de
um bloco que por sua vez é salvo.
13.1 - Quando uma tabela (struct) é inicializada, seu estado de dado mais recente é lido
de dentro da blockchain.


--- pendente

1 - Criar recurso para transferencia de units (entre contas); - DONE
2 - CLI deve usar o recurso de Result, Error para chamadas;
3 - Gerar os .blk usando algum tipo de assinatura, assim nao fica facil
decompilar o arquivo. - FEITO USANDO AesEcb (default, ativado = false) - DONE
4 - Remover o uso do Lazy (náo é necessario) - É NECESSARIO AINDA - DONE
5 - get_chain() -> deve ter um filtro para buscar os blocos até achar o valor,
e não buscar todos os blocos, alocar em memoria e depois fazer a busca. Isso vai 
prejudicar a memória se continuar no jeito atual. - DONE

6 - Criar os core contracts dentro da pasta/mod "core_tables" - DONE
6.1 - Criar metodo para criar DB [salvar num core table] - IGNORADO
6.2 - Criar método para checar se um DB existe - NAO NECESSÁRIO, O USUARIO
DEVE SABER QUE OS DADOS DE ACESSO SAO A CHAVE, SE PERDER OU ERRA DEPOIS, PERDE ACESSO
AOS DADOS. Cada banco é gerado a partir desses dados iniciais. - DONE
6.3 - Create Account: Usar email para evitar a colisao de mesma conta - IGNORADO
Salva o user_name em um contrato/tabela (core-table) diferente para que seja possível
fazer uma comparacao rapida e ver se o user_name já está sendo utilizado. - DONE
7 - Usar o db_access_key para encriptografar e decriptografar blocos - DONE
8 - Criar testes
9 - Tratar o que puder de unwrap()
9 - Usar compressao de arquivo? (zip?) - FEITO, MAS NAO COMPENSA. REMOVIDO!
10 - Mudar os Types de Requisicoes HTTP para o final Payload ao invés de Data - DONE
11 - Implantar sistema de query?
12 - IMPORTANTE: porque estou serializando o data de transacoes com json?
Eu sei que preciso passar o "data" como string, mas... talvez eu possa simplesmente
mudar o tipo para ser um Vec<u8>, e decompilar ele quando for requisitado - MELHOR JSON - DONE
13 - Implementar feature para buscar transacoes by user_id - DONE
14 - Remover logs do rocket
15 - Gerar documentação com Postman ou apenas no Readme
16 - Criar ChainDB-Rust (lib)


// O Bloco continua legível, apenas suas transacoes sao encriptografadas
// O Bloco é salvo em Base64 contendo dentro de si as transactions (encriptografas usando AesEcb)
// Borsh é usado para gerar string de bytes, gera final menor que json
// Processo baseado no que gerou menos dados no final do arquivo

[IMPORTANTE] Nao é possivel user Borsh por causa da estruta de dados. As vezes o dado da transacao é desconhecido
pelo sistema, ja que ele vem do client.


---- APP DE EXEMPLO PARA DEMO ----
1 - Tracking - Aplicativo para guardar posição de usuário/carro
1.1 - Depois, poder ver o trajeto percorrido no maps

2 - Delivery Tracking - Registra o lugar que um produto emprestado (de uma empresa) está.
2.1 - É possivel ver todo o historico do produto, usuários que o alugaram, lugares onde
pararam...

3 - Traquear temperatura do dia para levantamento de relatorio semanal, mensal, anual...



IMPORTANTE: Corrigir o problema de converter Vec<u8> em string literalmente números.
Usar o Base64VecU8 pra isso. Vai diminuir o tamanho do dado encriptografado.